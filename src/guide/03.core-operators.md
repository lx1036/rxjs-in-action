---
title: 3. 核心操作符(Core operators)
type: guide
order: 301
---

本章节覆盖
* 介绍流的处理
* 探讨常用的 RxJS 操作符
* 使用 map, reduce 和 filter 构建流畅的方法链
* 其他聚合操作符

在前面两章中，你已经了解到 RxJS 灵感来源于函数式编程和响应式编程。这两种范式都是围绕着数据流，并通过被称为操作符的函数链来传播数据变化。操作符是纯函数(pure function)，会基于当前的可观察对象创建新的，但是不改变原始可观察对象。在本章中，你将学习到如何使用常用操作符来创建管道，从而转换事件序列获得你想要的结果。

本章将使用函数式编程的声明式风格来创建可观察对象，你可以使用任意数量的数据，甚至随时间推移生成的数据来创建可观察对象，目的是为了创建静态或动态数据的统一编程模型。在深入理解操作数据流的操作符之前，需要明白可观察对象是可以取消的，而许多 AJAX 库却不可以。

## 3.1 流的取值和取消

假设有人创建了一个长执行时的 AJAX 调用，正在从服务器请求相当大量的数据。但是不久，用户点击其他按钮从当前页面离开，这时候这个最初的 AJAX 请求会如何处理？再考虑另外一个例子。你在客户端创建一个定时轮询获取数据，但是突然发生异常，数据也不可用，是否还允许这些进程继续运行并占用系统资源呢？答案应该是否定的。

RxJS 中的流就是一个可由程序员完全控制生命周期的对象，不像其他语言，JavaScript 数据类型很少，多数类型就和 JSON 一样简洁。此外，在内存管理方面 JavaScript 也极少提供支持，因为这历史上一直是浏览器厂商关心的问题。尽管这会使 JavaScript 变得简单易学，但是理解你程序内部运行状况会变得很难。

在像 C 和 C++ 这样的语言中，有着极其细粒度的方式，来控制所使用的特定数据结构，以及数据在内存中确切的使用期限 - 你可以完全控制内存的分配和释放内存中的对象。然而，在 JavaScript 中，对象的使用期限是由垃圾收集器控制的，这是正常情况。垃圾收集器是执行应用程序的运行时引擎所控制的进程。它将定期执行，并且释放所有未使用引用(references)所关联的内存。垃圾收集器通过跟踪应用程序各个对象之间保留的引用来实现 - 这就是所谓的引用计数。当它检测到一个对象不再被引用时，它将成为一个待清理项。如果无法找到不再使用的引用，就会造成内存泄漏。内存泄漏，通常是含糊设计或不清楚引用追踪的表现，可能会造成系统执行失控，此时如果应用程序无法响应，就会导致用户用户或系统去结束你的应用程序。

> 警告 自动垃圾收集这个概念，给了 JavaScript 开发人员一个错觉，我们不需要关心内存管理。这在我们尝试自己编写事件处理代码时，是错误的做法。RxJS 通过实现取消订阅机制或者从任何事件触发器（如 DOM）中有效地清理附加的监听器，将我们从内存管理这个问题中解脱出来。

在较早的浏览器实现中，这曾经是一个大问题，特别是 Internet Explorer 事件处理系统。而现在，现代浏览器能够更加高效地清理事件监听器来回收内存，并且像 RxJS 这样的库也进行相应设计以避免这些问题。

### 3.1.1 预先分配内存的不足之处

在使用 RxJS 时要牢记的一个要点是，流的使用期限并不是以创建可观察对象为开始。而是在可观察对象被订阅(subscribe)时开始。因此，在创建和初始时，流的性能消耗很小，因为它开始处于休眠状态，在没有观察者订阅的情况下不会生成或发出事件。有句老话是：“如果一个观察者是由应用程序创建的，而没有人订阅它，它是否会触发一个事件？

在计算方面，仅在需要时才创建数据的对象，被称为惰性数据源。这种对象与 JavaScript 中的对象有着显著对比。术语 lazy 和 eager 分别指的是，应用程序何时向系统请求内存，以及预先请求多少内存。惰性分配(lazy allocation)是，在空间实际需要（或预期需要）时再去分配，而预先分配(eager allocation)是，只要对象被限定范围，就立刻在前期进行分配。在提前分配方案中，分配有一个前期成本，并且很可能的情况是过度分配，因为你不知道要使用多少空间。而在惰性分配方案中，会等到在运行时(runtime)需要用到空间再去分配。这种方案可以让框架非常智能，避免在某些情况下过度分配空间。为了阐述二者不同之处，我们会展示一个常见的 JavaScript 数组方法 slice()，在预先分配和惰性分配机制下是如何取值的。假设有一个可以从头到尾生成数字数组的 range(start, end) 函数。现在我们要生成无穷多个元素，并将取出前面五个元素，如图 3.1 中的方案。

图 3.1 在一个预先分配方案中，程序会在执行 slice(5) 函数之前停止，因为浏览器已经耗尽了内存。

这里是代码：

```
range(1, Number.POSITIVE_INFINITY).slice(0, 5); //-> 浏览器停止
```

由于 JavaScript 的预先取值特性，这段代码永远不会进入到 range() 函数，因为它会生成无穷多个数字（或者直到内存不足和崩溃）。换句话说，预先取值，意味着在进行下一步之前完整执行前一个表达式的每个部分。然而，如果 JavaScript 函数是惰性的，那么这里的代码只需要生成前五个元素，如图 3.2 所示。

图 3.2 在一个惰性分配方案中，等到表达式的结果真正需要用到时，运行时(runtime)才通过程序执行表达式，并且只会分配需要用到的资源。

在这种情况下，等到表达式的结果真正需要用到时，才会对表达式进行全部取值。而 RxJS 中的策略恰好如此：等到订阅者(subscriber)订阅完可观察对象的表达式后，然后才开始初始化任何所需的数据结构。稍后会看到，使用惰性取值方案，可以帮助 RxJS 对内部数据结构进行优化和重用。

### 3.1.2 惰性分配和订阅可观察对象

RxJS 通过两种方式避免过早分配数据。第一种是，正如我们前面提到的，使用惰性订阅机制。第二种是，可观察对象在触发事件后，立即推送数据，而不是将其静态地保存在内存中。在第 4 章中，我们会讨论缓冲操作符(buffering operators)，这个操作符可以将数据暂时存储一段时间，或者在满足某个条件后短暂地存储数据，这完全取决于你的实现。但是默认情况下，一旦收到数据，就立刻向下游发送数据。

惰性订阅(lazy subscription)，意味着可观察对象将保持休眠状态，等到一个它正在关注的事件被触发后才激活。考虑如下这个例子，每隔半秒，就重复生成一次事件：

```
const source$ = Rx.Observable.create(observer => {
  let i = 0;
  setInterval(() => {
    observer.next(i++); // 每隔 500 毫秒，这里的 interval 就会持续发出事件，直到此 interval 停止，事件才停止。
}, 500); });
```

与数组不同，可观察对象实例是一个可能内存无限增长的动态对象，然而它的内存分配却是固定的。一定要做到这样；否则，为用户的每次点击、按键或鼠标移动产生的数据，都分配内存并且存储，是无法接受的事情。想要激活上面的可订阅对象 source$，观察者必须首先通过 subscribe() 来订阅它。一次订阅调用，会把可观察对象的事件从它的休眠状态中解脱出来，并通知它可以开始产生值 - 在这个示例中，每半秒开始分发事件 1, 2, 3, 4, 5 等。由于可观察对象是对许多不同数据源的抽象，所以会因数据源的类型不同而效果不同（，这里我们只是举例说明）。

惰性订阅的第二个优势是，observable 默认不保存数据。在前面的示例中，interval 每次产生的事件，会立刻进行处理，然后丢弃。这就是我们所谓的「可观察对象本质上是流式，而不是池式」的确切含义。“流式”语义中所隐含着的「默认丢弃」，意味着你无须担心无限增长的内存，会无声无息地占用内存，而导致内存泄漏。在以原生 JavaScript 代码编写事件驱动时，如果在事件管理和处理上疏忽，就可能会发生内存泄漏，特别是在旧版本浏览器中。

### 3.1.3 处理订阅：显式地取消订阅

与分配内存同等重要的，是内存解除分配或重新分配给应用程序。例如，交互丰富的 JavaScript UI 可能会将事件处理函数绑定到数千个元素上。等到用户完成与 UI 某个部分的交互后，这些事件处理函数所创建的对象没有理由继续存在和占用内存。正如前面所讨论的，垃圾收集器在清理内存方面相当智能。不幸的是，只有在发现这些对象的引用是未使用状态，或者没有形成引用循环时才能这样进行清理工作，这通常会频繁出现在（用户自己编写的忘记重置对象状态或忽略引用循环的）事件处理的原生代码中。

用户很容易在初始化对象后，由于忘记它们的存在，而没有删除对它们的引用，从而造成应用程序永远无法恢复该内存（这可能不仅仅是一个小的脚本所关注的问题，也可能是现代重型客户端应用程序的也在关注的问题）。你可以在下面这些简单的代码中，更清晰地认识到这个问题，举个例子，我们可能在某个菜单项监听鼠标右键点击事件，然后显示一个自定义的上下文菜单：

```
document.addEventListener('mouseup', e => {
  if (e.button === 2)
    showCustomContextMenu();
  e.stopPropagation();
});
```

许多开发人员甚至可能无法意识到这个代码中存在的问题。问题在于，为了取消订阅此事件，我们还需要引用传递给事件处理器的函数（也就是内部的 lambda 表达式）。即使我们还记得最终要取消订阅，但由于我们可能很多时候都习惯地使用这个用法，所以我们最终创建了一个无法取消订阅的处理函数。更糟糕的是，如果我们嵌套了事件处理函数，或者还订阅了其他事件，我们会创建出更加复杂以及潜在的内存泄漏。

对于早期的 web 应用程序（Web 1.0 时代），内存释放并不是一个问题，因为页面之间的导航跳转，可以强制页面重新加载，从而清除了　JavaScript　的运行时(runtime)足迹。今天，随着单页面应用程序越来越流行（Web 2.0+ 时代），客户端变得更加功能先进和交互丰富，内存压力逐渐成为真正的威胁；现在可以想象到的是，加载到浏览器中的对象，可以存在于整个应用程序的生命周期内。

这一切并不是危言耸听。我们可以预见（就像从 JavaScript 创立以来的已经做了诸多改进，）垃圾收集器会继续改进（，以解决这些内存回收的问题），许多应用程序将毫无问题地运行。但正确的内存管理对于所有应用程序来说仍然是很好的习惯。

这就是为什么我们需要像 RxJS 这样的久经考验的库。在 RxJS 中，由生产者负责取消订阅。订阅关系(subscription)的管理，是通过调用 subscribe() 后返回的一个类型为 Subscription（在 RxJS 4 中也称为 Disposable）的订阅对象来处理的，此 subscription 订阅对象实现了处理源流(source stream)的机制。如果我们已经结束观察，并且不想再接收事件，我们可以调用 unsubscribe() 来拆除卸下它（指源流）；这被称为显式地取消订阅(explicit cancellation)。下面是一个简化的示例：

```
const mouseClicks = Rx.Observable.fromEvent(document, 'mouseup');
const subscription = mouseClicks.subscribe(someMouseClickObserver);

...片刻后
subscription.unsubscribe(); // 将流(stream)拆除卸下，通过 subscription.unsubscribe(); 释放资源
```

这个拆除卸下(tearing-down)过程，会阻止后续事件继续发送到所有注册过的观察者，并且会立即释放分配给可观察对象的所有资源。subscription 实例专门用于处理整个取消订阅过程，之所以可以这样做的原因，是因为我们会在每个可观察对象中，都定义了如何取消订阅关系(unsubscription)的处理逻辑。此外，正如你将在后面的章节中看到的，对于全体的 observable 都是如此行为，这意味着为流分配的所有资源都可以取消并清除，而无需额外的范例，也没有产生内存中孤立对象的风险。

回想一下，在第 2 章中，我们介绍了 Rx.Observable.create() 方法，此方法可用于创建任意的可观察对象。创建它的最后一步是，指出订阅后返回的 subscription 订阅对象该如何处理可观察对象，这是你必须实现的行为。回到我们的进度指示器代码，像这样，在最后添加取消订阅(unsubscription)机制。

> Listing 3.1 对可观察对象进行处理

```
const progressBar$ = Rx.Observable.create(observer => {
  const OFFSET = 3000;
  const SPEED =  50;
  let val = 0;
  let timeoutId = 0;
  function progress() {
    if(++val <= 100) {
      observer.next(val);
      timeoutId = setTimeout(progress, SPEED);
    } else {
      observer.complete();
    }
  };
  timeoutId  = setTimeout(progress, OFFSET);
  return () => { // 调用 unsubscribe 方法时执行的函数。描述了如何取消 timeout 的操作。
     clearTimeout(timeoutId);
  };
});
```

> 代码示例 切记，本章的所有代码，都可以在 RxJS in Action 的 GitHub 仓库（ https://github.com/RxJSInAction/rxjs-in-action ）中找到。

在可观察对象函数体的末尾处添加的函数，会成为返回的 Subscription 对象的 unsubscribe() 方法中的函数体。实质上，每一个可观察对象在创建过程中，都提供了自我销毁的钥匙。每当观察者触发订阅时，订阅对象(subscription)都必然会返回一个可以清除自己的取消方式（类似 try/catch 之后的 finally 子句）。由于每个可观察对象都具有这个内含(self-contained)的自我销毁按钮，所以你也可以组合它的所有订阅关系(subscription)，不管这个可观察对象背后隐含多复杂的逻辑，你都可以正确地解除这些订阅关系(subscription)。

> 自定义的可观察对象 如果使用 create() 创建一个自定义的可观察对象，并且在其中模拟了一个无限的 interval 流，你必须提供正确的取消订阅行为，否则它将无限期地运行，并导致内存泄漏。

迄今为止所展示的多数例子，都是设置时间间隔来产生事件，这些事件通过 clearInterval() 来取消。但是不支持取消的数据源发生了什么？接下来我们来看看。

### 3.1.4 
### 3.1.4 Cancellation mismatch between RxJS and other APIs

RxJS 可观察对象可以直接取消和处理事件流，但是在与其他 JavaScript APIs 结合使用时，这种简洁方式会带有欺骗性。比如，当试图取消由 Promise 封装生成的 Observable 对象时，你可能会遇到一些问题，请看下面代码。
RxJS observables provide a straightforward mechanism for cancelling and disposing of event streams. But this simplicity can be deceiving when used in conjunction with other JavaScript APIs. For example, you might encounter problems when trying to cancel observables that wrap promises; look at the next listing.

> 列表 3.2 订阅一个 Promise
> Listing 3.2 Disposing of a promise


```
const promise = new Promise((resolve, reject) => { // 创建一个 Promise，10 秒后解析值为 42
  setTimeout(() => {
    resolve(42);
  }, 10000);
});
promise.then(val => {
  console.log(`In then(): ${val}`); // 处理解析出的 Promise 值
});

const subscription$ = Rx.Observable.fromPromise(promise).subscribe(val => {
   console.log(`In subscribe(): ${val}`); // 封装 Promise 为 Observable
});
subscription$.unsubscribe(); // 取消订阅 Observable 对象
```

从列表 3.2 中可看出，。Observable 对象已经被释放，但令人惊讶的是，尽管你也试图取消订阅这个事件，但是 10 秒后还是会抛出如下打印值（很显然，JavaScript Promise 对象毕竟不会被打断）：

```
"In then(): 42"
```

究竟发生了什么？图 3.3 解释了整个内部过程。

图 3.3 取消订阅 Observable 不会影响其内部的 Promise

Promise 被设计为不可取消，这会发生什么。一旦 Promise 对象开始执行（进入进行中状态），它会试图变成已完成状态，不管是解析或是拒绝最后的结果，就像上文。

RxJS 很容易与外部 API 集成，但是你必须明白，释放单值的 API（如 Promise）和释放多值的 API（如 Observable），两者的设计哲学是不匹配的。上文就是一个使用案例，但是如果和 RxJS 没有意识到的 API 集成，也会出现不匹配情况。然而，大多数时候，你不必自己取消订阅，因为很多 RxJS 操作符会为你取消。

由于我们已经解释了如何创建和取消流，下一章节我们先以很多流行操作符开始，这些操作符对大多数 RxJS 程序很有必要。

## 3.2 流行的 RxJS Observable 操作符

尽管 RxJS 的订阅和取消语义对资源管理从而避免泄露事件处理器很有用，但它们也仅仅只是一部分内容而已。记住响应式思维的整个内容：不是通过创建自定义的 Observable，和通过 observer.next() 来推送事件，从而你自己去控制流，最好是放弃控制流，让流随着时间流逝自我响应—— 你希望它一直都是响应式的！意思是可以通过 RxJS 的工厂操作符（of()，from() 或其他工厂操作符）来封装感兴趣的事件源，然后创建
有一定事务逻辑的 Observable 对象。所以，响应式的意思是某个值在未来某时被推送时，程序会自动去一些事情。

这正是 RxJS 的闪光点，由于它包含大量开箱即用的操作符，所以你可以用这些操作符创建包含逻辑数据流动的流，实际上你可以创建流解决任何问题，包括创建响应式表单、拖放功能，甚至游戏。

一个操作符仅仅是一小块其声明的功能，你可以使用它来往 Observable 管道中注入一定的逻辑。操作符也是一个纯函数和高阶函数，它不会修改所操作的 Observable 对象，而是返回新的 Observable 对象并继续链式调用。函数式编程的最佳实践在这里发挥作用了，因为构成你解决方案基础的业务逻辑将会被这些函数合并，而这些函数应该尽可能多的使用纯函数。这些操作符可以在数据源到达消费者之前，去监测、修改、创建或者延迟这些数据，换句话说，你业务逻辑管道中的任何数据都可以被一个或多个操作符的组合去处理，这会驱动执行你程序中的纯函数。如果这些还不能满足你的需求，RxJS 操作符也可以延迟评估！

回想第二章的图 2.10，我们强调了计算任务的四个基础类型，并根据是否同步异步和是否单值多值得情况，划分成两个维度。操作单值相对是个简单的事情（所谓的单值流），因为你可以直接检测它的属性值来操作它。然而大多数时候，你希望流能释放一定范围的值而不是单个值，RxJS 的计算模型鼓励你使用函数的链式调用来处理数据，类似于组装流水线上的传送带，如图 3.4：

图 3.4 组装流水线上操作符代表一个个工作站，每一个工作站对传进来的数据都会执行自己的任务

RxJS 另一个重要的设计原则是提供一个你习惯的计算模型，由于受到 ES5 的 Array#extras API 的启发，RxJS 的核心操作符也主要类似于 map、filter 和 reduce 等等。由于这些操作符被频繁使用，就先看看这些操作符。

### 3.2.1 核心操作符

操作符可以被分为两类：对象方法和静态类方法。RxJS 5 的部分修订极大简化了 API，减少了操作符的数量，并简化了使用。因此，RxJS 5 的大多数操作符可以使用类静态或对象方法（当我们说对象方法时，说的是 Observable 对象使用点语法(.)去调用操作符）。

RxJS 内置了很多操作符来解决普遍性问题，比如，处理集合，从流中抽取元素，操作和转换数据，错误处理和其他问题。本部分主要聚焦三种操作符：map，filter，reduce，以及和 reduce 相似的 scan。这三种操作符会占用你 80% 的时间。

#### 映射操作符
目前你遇到的最常用的 RxJS 操作符是 **map()**，但 RxJS 并不是实现这个操作符的唯一库，所有库都会遵循函数式编程（FP）原则，该原则内 **map()** 属于转换类操作符类别，因为它会通过函数去处理 Observable 从而改变数据，所以它是单个输出值或一对一转换。使用符号表示就是 x -> f(x)，x 值作为输入，f(x) 作为 x 的输出。举个例子，按一定比例处理价格集合：

```
const addSixPercent = x => x + (x * .06);
Rx.Observable.of(10.0, 20.0, 30.0, 40.0)
  .map(addSixPercent) // 函数作用于 Observable 的每个值
  .subscribe(console.log); //-> 10.6, 21.2, 31.8, 42.4
```

Mapping functions is a fundamental process when transforming data from one type to another. For example, say you had a list of user IDs for which you wanted to fetch GitHub information. Mapping a function like ajax() over the set of IDs yields an array of JSON account objects.

In RxJS, you want to map functions across all the elements emitted from an observable. To help you better visualize operators, we’ll use the marble diagrams. Recall that arrows and symbolic characters represent the various operations that convert the input stream into the output stream, as shown in figure 3.5.

Figure 3.5 The map operator will produce a one-to-one transformation that will convert an input value into an output value by a given process. In this case, map takes a URL string and converts it into an array of users by means of the mapping function. In the diagram, operators are encoded inside a box that illustrates the function that’s passed in.

We’ll use these vertical transformations in figure 3.5 to depict operations that take one form of data and convert it to another. By design, this function in RxJS has the exact same signature as that of [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map.):

```
Array.prototype.map         :: a => b; for all a in Array<a>
Rx.Observable.prototype.map :: a => b; for all a in Observable<a>
```

Like with arrays, observable’s map() is immutable, which means it won’t change the original but instead will transform the value passed through it. Also, as you can see in figure 3.5, the output will always be the same size as the input because mapping is a one-to-one relationship that preserves structure. It’s left up to you to decide exactly what the transform function is, depending on your business logic; map() simply guarantees that it will be called on every value passing through the stream as it’s propagated downstream to the next operator in the chain.

We mentioned briefly before that all RxJS operators are pure. To show you what this means, we’ll demonstrate the case of map(). Transforming a String into an ID looks like figure 3.6.

Figure 3.6 Mapping a function from String to Array to a source Observable creates a new Observable with the result of the function.

Now, let’s look at the code for this. Suppose you need to convert a collection of strings into a corresponding comma-separated value (CSV) array. Here’s a simple stream that will accomplish this.

> Listing 3.3 Mapping functions over streams

```
Rx.Observable.from([
  'The quick brown fox',
  'jumps over the lazy dog'
])
  .map(str => str.split(' ')) // Maps a set of functions to extract the value from
  .do(arr => console.log(arr.length)) // RxJS .do() is a utility operator that’s useful for effective actions such as logging to the screen. This can be handy for debugging or tracing the values flowing through a stream.
  .subscribe(console.log);
```

For those familiar with design patterns, mapping functions is analogous to the adapter pattern (as shown in the famous “Gang of Four” book titled Design Patterns: Elements of Reusable Object-Oriented Software). In the adapter pattern, an object interacts with two otherwise incompatible interfaces and allows information to flow between them, adapting them to each other. In a similar fashion, you use map() to create a type compatibility between the producer and the consumer of data. The purpose of using it is to convert the raw input data into something the consumers can understand. In this way, the adaptation is done from the producer to the consumer.

But sometimes there can be too much data to process, and you may not be interested in all of it. For this, there’s an operator to discard unwanted events.

__FILTERING OUT UNWANTED EVENTS__

Filtering is the process of removing unwanted items from a stream. The criteria to remove these elements is passed in as a selector function, also called the predicate. Here’s a simple example of how this operator works. Say you need you need to place restrictions on input boxes for numerical quantities. It’s probably a good idea to place a business rule over text boxes rejecting any non-numerical input. Whenever you’re thinking about rejecting, removing, narrowing, or selecting data, you can do that easily using a filtering operator called filter() and inspecting the keyCode property of the keystroke, as shown in the following listing.

> Listing 3.4 Filtering events from a stream

```
const isNumericalKeyCode = code => code >= 48 && code <= 57;
const input = document.querySelector('#input');
Rx.Observable.fromEvent(input, 'keyup')
  .pluck('keyCode') // Extracts this property from the object passing through the observable
  .filter(isNumericalKeyCode) // Accepts only keys in the numerical range
  .subscribe(code => console.log(`User typed:
    ${String.fromCharCode(code)}`));
```

Also, you can use it to ignore unwanted mouse clicks, touch events, and others. It could be that you’re interested only in data that meets certain criteria, or you need only a certain subset of the data. In some cases, allowing too much data through can have an adverse effect on the performance of your application. Think about building an API for users to access their account history for the month; if on every request you simply dump their entire account history, you’d quickly find both your API and your clients overwhelmed. To make matters worse, your application won’t scale to the size of data being processed. Filtering could be used to generate different views if the user wanted only debits, credits, or transactions after a certain month.

An easy way to think about filtering is to consider the job interview process (every developer’s favorite activity). When recruiting people for a specific job, one of the first things to look for is the candidates’ previous experience in order to determine if they have the right skill-set for the position. If the job requires programming, then you’d expect that the candidates should have some sort of programming background listed on their resume. If not, you could exclude them from your final interview list.

Suppose you modeled your applicant-screening process as an array; then, you could write your filtering operation using the array’s filter()2 method. Because observables implement the same filtering semantics, you’re already familiar with using a predicate function (also called a discriminant) in filter() that returns true for candidates who will be selected to move on to the next round. Here’s the dataset you’ll use:

```
let candidates = [
  {name: 'Brendan Eich', experience : 'JavaScript Inventor'},
  {name: 'Emmet Brown', experience: 'Historian'},
  {name: 'George Lucas', experience: 'Sci-fi writer'},
  {name: 'Alberto Perez', experience: 'Zumba Instructor'},
  {name: 'Bjarne Stroustrup', experience: 'C++ Developer'}
];
```

Whether this data arrives because of an AJAX call or a DOM event, the observable treats it all the same way. So for now, you’ll stick with a simple array. In this case, you can wrap the data with an observable and keep only the candidates who will be considered for this JavaScript job:

```
const hasJsExperience = bg => bg.toLowerCase().includes('javascript');

const candidates$ = Rx.Observable.from(candidates);
candidates$
  .filter(candidate => hasJsExperience(candidate.experience)) //#A
  .subscribe(console.log); //-> prints "Brendan Eich"
```

Figure 3.7 shows what’s happening behind the scenes. Like map(), filter() works vertically removing values from the resulting stream.

Figure 3.7 The filter operator is used to discard candidates who don’t have any JavaScript experience.

Functions map() and filter() are similar in that they take a single function as their parameter. But whereas the function passed to map converted the input value into an output value, the filter() function is used merely as a criterion that decides whether to keep the event in the stream or not. As you know, JavaScript being loosely typed will accept any “truthy” value as a pass, while any “falsy” values will cause it to reject the event.

> Truthy vs. falsy
> In JavaScript, truthy is any value that can be coerced to a true Boolean value. This includes objects, arrays, non-zero numbers, non-empty strings, and of course the true Boolean value. Meanwhile, falsy would be represented by 0, ' ', null, undefined, or false. In practice, although JavaScript will accept all these types without question, it’s often best for clarity’s sake to return a Boolean value.

map and `filter` work well together in scenarios where you don’t want to apply a mapping function to each element but apply it to only the subset you care about. But filter isn’t the only function married to map; let’s not forget about the powerful map/reduce combinations.

__AGGREGATING RESULTS WITH REDUCE__

Sometimes you aren’t interested in acting on each item in a collection in isolation; sometimes you want to look at the collection in aggregate rather than piecemeal. For instance, suppose you want to take the average value of a collection of numbers or you want to turn a sequence into a mathematical series. This type of operation is called a reduction or an aggregation, with the result as a single value output instead of another collection. Once again, arrays come with a built-in reduce operator for this purpose,3 and observables follow suit. reduce is a bit more involved than the other two; here’s the function signature:

```
Rx.Observable.reduce(accumulatorFunction, [initialValue]);
```

The accumulator function is called on every element, and it’s given the current running total and the new value as parameters. The initial value (optional) is used to begin the accumulation process; we’re using 0 to begin the addition. Here’s a simple example to illustrate how reduce() works. Suppose you want to compute the user’s spending for the month by totaling all their transactions. For this example, these transaction objects have a property called amount.

> Listing 3.5 Using reduce() to compute spending

```
const add = (x, y) => x + y;
Rx.Observable.from([
  {
    date: '2016-07-01',
    amount: -320.00,
  }, {
    date: '2016-07-13',
    amount: 1000.00,
  },
  {
    date: '2016-07-22',
    amount: 45.0,
  },
])
  .pluck('amount') // Extracts the amount property
  .reduce(add, 0) // Reduces the set of amount values with an add function
  .subscribe(console.log);
```

It’s important to notice that reduce() with observables works a bit differently than map() and filter(). With arrays, reduce() doesn’t return another array; instead, it produces a single raw value, which is the result of the reduction. The observable’s reduce(), on the other hand, continues the previous pattern of returning a new singleton observable. This distinction will become important in section 3.3 when we talk more about operator chaining. Figure 3.8 is a visual representation of the previous code. Reduction is an operation that moves horizontally through the stream.

Figure 3.8 The reduce operator moving horizontally, accumulating every value through the stream using the add function

Suppose you needed to traverse through the candidate stream and group all the candidates with a technical background (that is, with knowledge of C++ or JavaScript):

```
Rx.Observable.from(candidates)
  .filter(candidate => { // Filters all candidates who have no knowledge of a programming language
    const bg = candidate.experience.toLowerCase();
    return bg.includes('javascript') || bg.includes('c++');
  })
  .reduce((acc, obj) => {
    acc.push(obj.name); // Adds a candidate name to the array
    return acc;
  }, []) // Begins with an empty array (called the seed)
  .subscribe(console.log); //-> ["Brendan Eich", "Bjarne Stroustrup"]
```

As you can see, reduce applies an accumulator function over the observable sequence initialized with the first seed value, which will be used to begin the aggregation process. Because reduce() returns a single value, there’s a need for partial accumulation as well. We’ll look at a variation of reduce() called scan().

__SCANNING AGGREGATE DATA__

RxJS uses scan() to apply an accumulator function over an observable sequence (just like reduce()) but returns each intermediate result as the accumulation process is happening and not all at once. This is useful to obtain progress information about how data is being aggregated with each event.

Changing the previous code to use scan() as a direct swap-in replacement of reduce() reveals the intermediate steps of the accumulation:

```
Rx.Observable.from(candidates)
  .filter(candidate => {
    const bg = candidate.experience.toLowerCase();
    return bg.includes('javascript') || bg.includes('c++');
  })
  .scan((acc, obj) => { // Scan can be used as a direct replacement of reduce. In RxJS 4, you would have had to change the seed parameter to be the first one. This was fixed in RxJS 5, with scan now having the same signature as reduce.
    acc.push(obj.name);
    return acc;
  }, [])
  .subscribe(console.log);
//-> ["Brendan Eich"]
     ["Brendan Eich", "Bjarne Stroustrup"] // As soon as it finds the first event, it emits it and accumulates it. A second emission happens when the second event is found, returning the current state of the accumulation.
```

Aside from scan(), the symmetries between arrays and observables are no coincidence. This signature was chosen specifically because it’s so simple and because it’s one that many JavaScript developers are already familiar with. But here the similarities end. Remember that these methods by themselves don’t cause any work to run on the stream (only a subscriber can); instead, when an operator is called on an observable, it’s configuring the observable for future values. Recall our definition of a stream as a specification of a dynamic value. This is a key distinction between the operators that you’ll see with arrays and those with observables, and you’ll learn in later chapters that arrays represent work happening now, whereas observables represent work in the future.

## 3.3 Sequencing operator pipelines with aggregates

One principle of FP is the ability to construct lazy function chains. In this section, we’ll show you how to mix and match the main observable operators you just learned about together with a few other functions known as aggregates. Aggregate functions let you do useful things like keeping track of a running total, taking only a subset of the total set of data, returning default values, and others. Some functional libraries you might have heard of or used before, such as Lodash.js and Underscore.js, have ample support for this. First, it’s important to understand that observable sequences must be self-contained.

### 3.3.1 Self-contained pipelines and referential transparency

Function chains utilize JavaScript’s power of higher-order functions to act as the single providers of the business logic. You saw examples of this before such as the filter function taking a predicate parameter. Also, observable pipelines should be self-contained, which essentially means they’re side effect–free (keep in mind that if your business logic functions are pure, your entire program is pure and stable as well). A pure pipeline doesn’t allow any references to leak out of the observable’s context. Once an event is lifted into the context, it’s contained and transformed through a sequence of operators. Earlier we showed that it’s possible to group operations together to create more-expressive logic. In RxJS, we call this process operator chaining or fluent programming. The analogy of a self-contained pipeline works great as a visualization aid, as shown in figure 3.9.
    Consider this example:

```
let sinceLast = new Date();
Rx.Observable.fromEvent(document, 'mouseup')
  .filter(e => {
    let timeElapsed = new Date() - sinceLast;
    sinceLast = new Date(); // Careless side effects of reading and writing to an external variable
    return timeElapsed < 200;
  })
  .subscribe(() => console.log('double clicked'));
```

Figure 3.9 A self-contained pipeline is one where all of its operations are side effect–free and work strictly on the data coming from previous operators. Operators might be any of map, filter, reduce, and others you’ll learn about in this book.

This code is an example of poorly designed scope management in which the state variable sinceLast is allowed to live outside the observable’s context. The result is that the observable is no longer stateless, and the lifecycles of the state and the observable are now dependent on each other.

It’s important to understand that when you create an observable, you’re creating an ecosystem or a bounded context. That ecosystem is a closed loop that begins with a subscription and ends with a disposal. If you were to look at the observable through an FP lens, you’d see that the internals of that observable remain completely stateless and walled off somewhat from the rest of the application. The scope of the callbacks that are passed into the operators should remain small and local. Mixing code that has external side effects not only introduces difficult-to-track complexity but also removes one of the key advantages to using observables, which is their well-defined lifespan -  creation and disposal should leave the system in the same state they found it in.

> What is a bounded context?
> A bounded context is a design principle originating from domain-driven design, which states that entities pertaining to a single domain model should be highly cohesive and expose only the necessary interface to interact with other contexts. You can extend this definition to the Observable type as a form of context that hides the nature of the data that’s pushed through it, allowing you to transform it by a ubiquitous language made up from the limited set of operators being exposed and independently of what happens in the outside world.

At a glance, a single subscription to this observable will function correctly, assuming that no other code manipulates sinceLast. But if this observable is subscribed to a second time, the result is no longer the same. An observable must always produce the same results given the same events passing through it (that is, pressing the same key combination should always yield the same data to the observers), a quality known in FP as referential transparency.

Each invocation of subscribe() does more than start an event emitter. It spins off a brand-new pipeline that will be independent of any other pipelines that were created by subsequent calls to subscribe(). This behavior is intentional in order to minimize side effects and be referentially transparent; similarly, the result of an observable should be the result of the data passed through it, not the number of parallel observables that are also active. You’ll see in the next chapter on dealing with time in RxJS that the sort of operation used in the previous code sample is unnecessary.

As mentioned earlier, the operator chain is core to the design of an RxJS operator: every operator must perform some work on the data passing through it and then wrap it into another observable instance that gets returned.[4](https://github.com/ReactiveX/rxjs/blob/master/doc/operator-creation.md#advanced) In this manner, the subscription gets internally passed around from one context to the next. To show how this works, you’ll add your own operator using prototype extension (using ES6, you could also do it by extending from the Observable class); this operator is the logical inverse of filter(), called exclude(), and is shown in the next listing.

> Listing 3.6 Custom exclude operator

```
function exclude(predicate) {
  return Rx.Observable.create(subscriber => { // Creates a new observable context to return with the new result
    let source = this; // Because you’re in a lambda function, “this” points to the outer scope.
    return source.subscribe(
      value => {
        try { // Catches errors from user-provided callbacks
          if(!predicate(value)) {
            subscriber.next(value); // Passes the next value to the new operator in the chain
          }
        }
        catch(err) {
          subscriber.error(err);
        }
      },
      err => subscriber.error(err), // Be sure to handle errors appropriately and pass them along.
      () => subscriber.complete()
    );
  });
}
Rx.Observable.prototype.exclude = exclude; // Adds the operator by extending the Observable prototype
```

As you can see from this snippet, every operator creates a brand-new observable, transforming the data in its own way and delegating it to the next subscriber in the chain. You can use it to exclude all even numbers as such:

```
Rx.Observable.from([1, 2, 3, 4, 5])
  .exclude(x => x % 2 === 0)
  .subscribe(console.log);
```

Furthermore, operation chaining in combination with an observable’s lazy evaluation gives RxJS an important performance advantage over arrays, which we’ll discuss next.

### 3.3.2 Performance advantages of sequencing with RxJS

Aside from the declarative style of development that encourages you to write side effect–free code, the primary advantage of using observable operators is that there is little or no performance penalty for chaining two methods like map and filter. Behind the scenes, RxJS produces little overhead because observables themselves are lightweight and inexpensive to create. On the other hand, operator calls on arrays create new instances along the way, which naturally incurs more memory allocations when the collection being processed is large. You can see this with a simple example that uses the full set of parameters for map() and filter() array functions:

```
const original = [1, 2, 3];
const result = original
  .filter((x, idx, arr) => {
    console.log(`filtering ${x}, same as original? ${original === arr}`);
    return x % 2 !== 0;
  })
  .map((x, idx, arr) => {
    console.log(`mapping, same as original?  ${original === arr}`);
    return x * x;
  });
result; //-> [1, 9]

Logging to the console within the pipeline is considered a side effect. We’re bending the rule here a bit to illustrate this concept.

map and filter expose extra parameters such as the current index and the source array. Typical implementations of these methods don’t use these parameters, but it’s good to know they’re there.
```

Running this code logs the following messages:

```
"filtering, same as original? true"
"filtering, same as original? true"
"filtering, same as original? true"
"mapping, same as original? false"
"mapping, same as original? false"
```

You can visualize the difference between both approaches in figure 3.10.

Figure 3.10 The array’s filter and map operators generate intermediate, wasteful data structures. RxJS observables are optimized and process events entirely through all functions at once, avoiding intermediate storage altogether.

RxJS, by contrast, doesn’t create intermediate data structures. As you can see in the previous example, filter() works on the same data structure as the original because it’s first on the chain. This operation returns a brand-new array instance that becomes the new owning object on which you call map. This can be inefficient on very large collections because new data structures are created and used only once before being garbage collected. In RxJS, the underlying data structure is optimized to process each item through the pipeline from the producer to the consumer at once, avoiding the creation of extra data structures along the way. Let’s convert the same code to use observables:

```
Rx.Observable.from(original)
  .filter(x => {
    console.log(`filtering ${x}`);
    return x % 2 !== 0;
  })
  .map(x => {
    console.log(`mapping ${x}`);
    return x * x;
  })
  .subscribe();
```

Running this code shows you that each element (or mouse click, key press, asynchronous data, and others) passes through the pipeline by itself without creating intermediary storage. The first value, 1, passes through filtering and then through mapping before 2 and 3 are looked at:

```
"filtering 1"
"mapping 1"
"filtering 2"
"filtering 3"
"mapping 3"
```

Now this is optimal. This fluent chaining pattern hinges on the return type of all observable methods to always return observables. As you know, in arrays, the reduce operator breaks the chain of commands because it doesn’t return an array, so further chaining becomes impossible. In RxJS, every operator will return an observable instance so that it can support further chaining. This property means that a virtually unlimited variety of combinations can be assembled. Whereas observables are abstractions over various data sources, their operators are just abstractions of those abstractions. That is, just like the adapter methods used to create observables from other library types, an operator is simply an adapter to convert an existing observable into a new one with more-specific functionality.

Before we continue having fun building more chains, we’ll introduce another set of aggregate methods that will become handy for building nice expressive business logic. Table 3.1 briefly explains each of these aggregate functions.

Table 3.1 More aggregate operators

Name | Description
-- | --
take(count) | Filtering operator. Returns a specified amount (count) of contiguous elements from an observable sequence. Later, you’ll see this is useful to extract a finite set of events from an otherwise infinite stream.
first, last | A refinement on the take function. Returns the first element in the observable stream or the last, respectively.
min, max | Filtering operators. Work on observables that emit numbers returning the minimum or maximum value of a finite stream, respectively.
do | Utility operator. Invokes an action for each element in the observable sequence to perform some type of side effect. This operator is for debugging and tracing purposes and can be plugged into any step in the pipeline.

Now, let’s have fun with some examples that put some of these to work.

> Listing 3.7 Using aggregate operators

```
Rx.Observable.from(candidates)
  .pluck('experience')
  .take(2) // Takes only the first two elements (another filtering operator)
  .do(val => console.log(`Visiting ${val}`)) // Performs the logging routine and passes along the observable sequence
  .subscribe(); // prints "Visiting JavaScript Guru"
                          "Visiting Historian"
```

> Effectful computations
> The do operator is known as an effectful computation, which means it will typically cause an effect such as I/O, a database insert, append to the DOM, or write to a file - all of these side effects, of course. The reason why do() still preserves the chain is rooted in an FP artifact called the K combinator. In simple terms, this is a function that executes any effect but ignores its outcome, just passing the value along in the stream to the next operator. In a way, it’s a bridge that intercepts the stream that allows you to invoke any function. It’s known in other libraries as the tap() operator.

Being able to use this repertoire of operators is certainly beneficial because it frees you from having to write them yourself, reducing the probably for bugs to occur (you can find a complete list of all the operators used in this book in appendix B - you’re free to use it as a guide). Nevertheless, the functions passed into these operators are solely your responsibility, so please test them thoroughly. We’ll revisit testing further in chapter 9.

In this chapter, we talked at length about several of the core operators that come bundled with RxJS. We purposely avoided specifically enumerating all the operators that are available for mapping, filtering, and other tasks. That job is better left to the reference material on GitHub or on the internet.[5](http://xgrommx.github.io/rx-book/index.html) Instead, we wanted to demonstrate how operators are used in conjunction with observables to build chains of logic that let you write streams declaratively, so that they’re both easy to understand and easy to extend. We chose what we think of as the set of core operators. We explored how you can build complex logic intuitively using fluent operators. These are operators that act primarily on a single observable and don’t introduce any time-based operations. In the next chapter, we’ll explore the time aspect of observables, which allows you to handle future data.

## 3.4 Summary

* Streams provide their own mechanisms for cancellation and disposal, which is an improvement over JavaScript’s native event system.
* The Observable data type enables fluent function chaining that allows the sequential application of operators, using a model similar to that of arrays.
* Unlike JavaScript’s native promises, observables have built-in capabilities for disposal and cancellation.
* Functions injected into the operators of an observable sequence contain the business logic of your application and should be side effect–free.
* Observables are self-contained with indefinitely chainable operators.
